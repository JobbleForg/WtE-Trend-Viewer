# Waste-to-Energy Plant Data Viewer — Project Rundown

## Overview

This project is an Excel VBA-based trend viewer for power plant process data. It's designed to mimic DCS (Distributed Control System) trend displays like those found in ABB 800xA, allowing an engineer to quickly view, scroll, and compare tagged process variables from a fixed historical dataset.

The system is built for **quick deployment and disposal** — import a dataset, analyze it, discard it, and repeat with the next one. No persistent connections, no complex infrastructure.

---

## File Structure

| File | Purpose |
|------|---------|
| `JHS_review_02-26.xlsm` | Main workbook — contains all sheets, VBA code, charts, and controls |
| `Raw Data.xlsx` | Source data file — contains the "Customer Data" sheet with 23,039 rows of timestamped process data across 46 tags (columns B–AU) |

### Sheets in the Main Workbook

| Sheet | Purpose |
|-------|---------|
| **Customer Data** | Imported copy of the raw dataset. 23,040 rows (incl. header), 47 columns (timestamp + 46 tags). This is the single source of truth for all charts. |
| **Tag Refs** | Reference sheet mapping customer tag codes (e.g. AT1102) to friendly names (e.g. Ln1_O2_A), units, decimal places, Y-axis defaults, and chart package definitions. Pre-existing — not generated by VBA. |
| **Viewer** | The main user interface. Contains 4 trend charts, each with its own control panel (series selection, Y-axis limits, time window, scroll buttons). |
| **Staging Data** | Working area. Column A holds the tag list for dropdowns. Columns D–H hold the filtered data slice currently feeding Chart 1. Each chart gets its own column block here. |

---

## VBA Modules

### Module 1: `modImport` — Data Import

**Sub: `ImportCustomerData()`**

Imports data from `Raw Data.xlsx` into the "Customer Data" sheet.

**Why VBA instead of Power Query?** The system is designed for quick deploy/discard cycles. Power Query leaves behind connection metadata, refresh settings, and query definitions that need cleanup. VBA does a clean one-shot import with no residual connections.

**How it works:**
1. Checks that the source file exists at the hardcoded path
2. Disables screen updating for performance
3. Opens the source workbook read-only
4. Finds the data extent (last row and column) using the Ctrl+Up / Ctrl+Left pattern
5. Copies the entire range (headers + data) from source
6. Pastes as **values and formats only** — no formulas, no links back to the source
7. Closes the source file without saving
8. Reports the row/column count to the user

**Key design decision:** Paste as values ensures zero dependency on the source file after import. The source can be moved or deleted without affecting the workbook.

---

### Module 2: `modTagList` — Dropdown List Generator

**Sub: `BuildTagList()`**

Reads all tag code headers from row 1 of Customer Data (columns B through the last column) and writes them as a vertical list in Staging Data column A, starting at A2.

**Why this exists:** Excel Data Validation dropdowns need a list range to reference. This sub generates that list dynamically from whatever dataset was imported, so it works with any plant's data without manual editing.

**The dropdown list** is referenced by all series selection cells on the Viewer sheet via Data Validation → List → `='Staging Data'!$A$2:$A$47`.

---

### Module 3: `modChart1` — Chart 1 Engine

This module contains all the logic for Chart 1. The pattern will be replicated for Charts 2–4.

#### Module-level variable

```vb
Private dStartTime As Date
```

Holds the current left edge of the time window. Persists between sub calls within the session, allowing scroll buttons to shift it forward/back. Private scope means only code in this module can access it.

**Why a module-level variable?** The scroll buttons need to modify the start time and then call the update sub. If `dStartTime` were local to a sub, it would reset every call. Module-level keeps it alive.

---

#### Sub: `InitChart1()`

Sets `dStartTime` to the first timestamp in the dataset (Customer Data cell A2). Must be run once before using the chart, otherwise `dStartTime` defaults to zero (which VBA interprets as 30-Dec-1899).

---

#### Sub: `UpdateChart1()`

The central engine. Every user action (scroll, change series, change time window) calls this sub. It performs the following steps in order:

**Step 1 — Read control values from the Viewer sheet**

Reads all user inputs from their fixed cell addresses:

| Control | Cell | Type |
|---------|------|------|
| Series L1 (left axis) | C22 | Tag code string |
| Series L2 (left axis) | C23 | Tag code string |
| Series R1 (right axis) | G22 | Tag code string |
| Series R2 (right axis) | G23 | Tag code string |
| Y-Left High | E22 | Number |
| Y-Left Low | E23 | Number |
| Y-Right High | I22 | Number |
| Y-Right Low | I23 | Number |
| Time window (minutes) | J23 | Number |
| Time window (hours) | K23 | Number |
| Step size | L23 | Number |

Minutes and hours are combined: `windowMin = J23 + (K23 * 60)`.

The end time is calculated: `dEndTime = dStartTime + (windowMin / 1440)`. Division by 1440 converts minutes to Excel's date format where 1.0 = one day.

**Step 2 — Find column numbers for selected tags**

Uses `Application.Match()` to search row 1 of Customer Data for each selected tag code. Returns the column number, or an error if not found. Results are stored as `Variant` type because Match can return either a number or an error.

Only searches if the dropdown is not blank — avoids unnecessary errors.

**Step 3 — Find the row range for the time window**

Loops through Customer Data column A (timestamps) to find:
- `startRow`: first row where timestamp >= `dStartTime`
- `endRow`: last row where timestamp <= `dEndTime`

Exits the loop early once past the end time for performance. If no matching rows are found, shows a warning and exits the sub.

**Why loop instead of a formula?** With 23,000 sorted rows, a simple loop with early exit is fast and straightforward. More complex approaches (binary search, MATCH formula) add complexity for minimal gain at this data size.

**Step 4 — Write filtered data to Staging Data**

Copies only the matching rows and selected columns into Staging Data columns D–H:

| Staging Column | Content |
|----------------|---------|
| D | Timestamps |
| E | Series L1 values |
| F | Series L2 values |
| G | Series R1 values |
| H | Series R2 values |

Clears the previous staging data first. Uses `IsNumeric()` to check that each column was successfully found before writing.

**Why staging data?** The chart never sees all 23,000 rows. It only reads from this small filtered slice, which keeps chart rendering fast. This is the key architectural decision for performance.

**Step 5 — Create or reuse the chart**

Loops through all ChartObjects on the Viewer sheet looking for one named "TrendChart1". If found, reuses it. If not, creates a new one positioned to match cells B2:N21.

**Why not create a new chart every time?** Creating and destroying chart objects is slow and causes screen flicker. Creating once and updating the data is much faster and smoother.

**Step 6 — Clear and rebuild series**

Removes all existing series from the chart with a `Do While` loop, then adds new series from the staging data. Each series gets:
- A name (the tag code)
- X values (timestamp column from staging)
- Y values (the corresponding data column from staging)
- An axis group assignment (xlPrimary for left, xlSecondary for right)

**Why clear and rebuild instead of modifying?** The user might change which tags are selected, or how many. Rebuilding from scratch is simpler and avoids edge cases with mismatched series counts.

**Step 7 — Set Y-axis limits**

Applies the user's high/low values to the primary (left) and secondary (right) axes. Only sets limits if at least one series is assigned to that axis.

---

## Viewer Sheet Layout

Four trend charts arranged in a 2×2 grid. Each chart has a control panel directly below it.

### Chart 1 Layout

| Area | Cell Range |
|------|-----------|
| Chart | B2:N21 |
| Controls | Row 22–23 |

### Control Panel Layout (per chart)

```
Row 22: [Series L1] [dropdown] [Y-Left High] [value] [Series R1] [dropdown] [Y-Right High] [value] [Time window label]          [Step size] [Scrl left] [Scrl right]
Row 23: [Series L2] [dropdown] [Y-Left Low]  [value] [Series R2] [dropdown] [Y-Right Low]  [value] [min input] [hr input] [value]       [Button]    [Button]
```

---

## Design Decisions Summary

| Decision | Reasoning |
|----------|-----------|
| VBA over Power Query for import | No residual connections; clean for quick deploy/discard |
| Paste as values | Zero dependency on source file after import |
| Staging data pattern | Chart only sees a small filtered slice; keeps rendering fast on 23k rows |
| Module-level dStartTime | Persists between scroll button clicks without being global |
| Named chart objects | Create once, update many times; avoids slow recreation |
| Clear and rebuild series | Simpler than tracking which series changed; handles all edge cases |
| Data Validation dropdowns | Native Excel feature; no VBA needed for the UI element itself |
| Dynamic tag list from headers | Works with any dataset without manual editing |

---

## Still To Do

- [ ] Wire up scroll left/right buttons (`ScrollLeft` / `ScrollRight` subs)
- [ ] Replicate Chart 1 pattern to Charts 2, 3, and 4
- [ ] Add friendly names to tag list (from plant documentation)
- [ ] Style charts (dark background, colored traces — DCS aesthetic)
- [ ] Test with edge cases (empty dropdowns, window past data range, etc.)
